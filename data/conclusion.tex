% !Mode:: "TeX:UTF-8"

\chapter{总结与展望}

\section{总结}

在高性能处理器的分支预测研究领域中，为了提高分支预测准确率，大量的学者提出了各种各样的算法和改进措施，也取得了很好的效果。但是大部分论文中的算法设计都是基于模拟器进行性能分析，并没有考虑到现实物理设计时的限制，而商业处理器的分支预测具体设计大部分细节都不会公开。

而本文选用香山这一RISC-V开源高性能处理器作为平台，在其第一版雁栖湖架构的分支预测部件基础上进行了重构和改进，提出了一种新分支预测架构的设计实现，以下是主要的两个改进：

\begin{enumerate}
    \item 实现了限制分支预测宽度的设计。主要包含FTB的设计实现和分支预测单元的相关改动。将前端流水线的预测和取指基本单位由固定的32Bytes变为了可以限制每次取到的分支指令数量的数据结构Fetch Block，降低了分支预测同时预测分支指令的数量，减少了最终的选择逻辑层数。并且针对这一改动，重构了整个分支预测部件，将其中所有的分支预测器都改为适用于以Fetch Block为基本单位的模式，并针对Fetch Block的特性，从节省FTB的存储空间利用率以及减少FTB更新时读写次数方面做出了针对性的优化。保证在基本取指单位变动的情况下分支预测性能的保持，在南湖架构使用了更多的存储资源的前提下，在部分测试程序中分支预测准确率平均能够提升0.6\%。
    \item 实现了前端分支预测与取指单元解耦的设计，以此减少前端流水线的气泡。主要包含FTQ的设计实现和分支预测单元的相关改动。将取指单元的流水线移动到分支预测流水线之后，并且去除了之前分支预测使用取指单元相关信息的逻辑，例如使用预译码信息。此外由于拆分流水线导致前端总流水线深度加深，带来更高的分支预测误预测惩罚，因此提出了了分支预测预写入FTQ的策略，在S1就提前将取指请求送往FTQ，之后再将剩余的信息补充写入，达到减少误预测惩罚的目的。
\end{enumerate}

本文提出并实现了一种能够限制分支预测宽度和解耦前端流水线的分支预测架构，最终作为香山处理器第二版南湖架构的分支预测组件设计，即将送往流片。南湖架构相对于雁栖湖架构来说，分支预测性能，总体性能和频率都有一定的提升。在相同的14nm工艺下，使用Design Compiler进行评估，整体的频率能够从雁栖湖架构的1.8GHz提升到2.0GHz，提升了11\%，且从SPEC CPU 2006下的部分测试程序结果来看，整体IPC性能能够提升30.96\%，分支预测准确率提升0.6\%。

\section{展望}

本文提出的分支预测架构在雁栖湖架构的基础上做出了改进，取得了良好的效果，但是其实目前的设计还有很多不足和待改进的地方。这里提出一部分改进思路和未来的研究方向：

\begin{enumerate}
    \item 在开发过程中，如何快速准确的对分支预测部件进行功能评估，一直是一个没有解决的问题，由于分支预测本身就是一个预测性质的功能，即使预测错误也只是会造成性能损失，不会出现功能上的错误，因此香山的差分测试框架难以找到分支预测实现上的bug。如何测试分支预测运行时各种功能是否正常，是一个非常值得深入研究的课题。可以尝试实现类似于香山差分测试框架的专门针对分支预测的差分测试，模拟出与真实硬件中相同的预测器，通过比较模拟器和仿真的执行过程中的一些关键数据，来验证分支预测是否按照预期运行。该思路的难点在于如何设计实现模拟器，需要怎样的模拟粒度能够在保证与真实硬件运行状态相同的同时又有较快的模拟速度，以免过慢的运行速度影响整体的验证迭代过程。
    \item 在香山下一版的设计，以及未来的每次迭代中，对频率和性能的要求肯定是越来越高的，因此在南湖架构的基础上，需要考虑如何能够做到更高的频率，如何做到更高的分支预测准确率，都是值得研究的课题。可能分支预测的整体框架还要大幅的改动。依然需要不断地和其他企业高校团队多沟通交流，阅读相关领域的会议论文和期刊，尽可能了解其他团队的实现思路，掌握最先进的技术。同时也要着重验证环境和流程的同步开发，只有提高验证能力，才能够在多样的改进思路中准确的选择出效率最高的路线。
    \item 在雁栖湖架构的设计中，分支预测里实现了循环预测器，但是在南湖架构中移除了它，主要是因为南湖架构使用了非对齐的取指策略，同一条分支可能存在于不同的Fetch Block中，这样对于循环预测器的实现带来了一些问题，循环预测器无法准确的记录某条循环跳转指令的迭代次数。因此之后如何设计实现循环预测器，将其加入到分支预测中，也是一个未来的改进方向。此外雁栖湖架构中的循环预测器在测试中对处理器整体的性能提升有限，之后也可针对循环预测器对处理器性能提升的效果进行研究，探索不同策略，不同基准测试下循环预测器的效果，尽可能降低在简单循环中误预测指令的数量。
\end{enumerate}

